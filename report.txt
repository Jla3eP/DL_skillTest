В начале подумал, что всё совсем просто и неделя на такую задачку это совсем много. 
На следующий день, когда решил садиться писать, понял, что всё немного сложнее и простой поиск кратчайшего пути на графе это не то.

Немного погуглив, нашёл название такой задачи, нашёл алгоритмы, выбрал метод имитации отжига.
Также, в целях избежания дублирования кода, сразу решил, что функцию, которая считает общий "вес" пути, буду передавать как параметр.

Для времени решил создать собственную реализацию в целях экономии ресурсов и создания необходимого функционала. Хранил ввиде uint секунд.

Граф представил в виде матрицы (train/matrix)

Так как граф неполный (не для всех пар станция-станция существует прямой маршрут), 
потребовалось создать дополнительные функции валидации и поиска валидного пути (findValidWay, isValid).

Суть алгоритма: 

1) Вносим в путь случайное изменение.
2) Если новый маршрут лучше, принимаем его за новый, температура остаётся на прежнем уровне.
3) Если новый маршрут хуже, принимаем его с вероятностью, которая зависит от двух параметров: температуры и разницы в "длине" пути. 
   Увеличиваем счётчик итераций (температура уменьшается).
4) Повторяем до тех пор, пора текущая температура выше заданной минимальной.
